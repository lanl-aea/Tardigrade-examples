#! /usr/bin/env python

""" Workflow for running an Abaqus/Standard simulation of a Brazilian disk indirect tension experiment with loading platens
Requires the following ``Sconscript(..., exports=[])``
* ``env`` - The SCons construction environment with the following required keys
  * ``DNS_Abaqus_abspath`` - String absolute path to the Abaqus journal files
  * ``Tardigrade_MOOSE_source_abspath`` - String path for the Tardigrade-MOOSE application
  * ``mesh_templates_abspath`` - String absolute path to model_package/meshes
"""

import pathlib

import numpy
import waves

from model_package.Tardigrade_MOOSE import simulation_variables_nominal


# Inherit the parent construction environment
Import('env')

# set project-wide paths with os-agnostic path separators
DNS_Abaqus_abspath = pathlib.Path(env["DNS_Abaqus_abspath"])
Tardigrade_MOOSE_source_abspath = pathlib.Path(env["Tardigrade_MOOSE_source_abspath"])
mesh_templates_abspath = pathlib.Path(env["mesh_templates_abspath"])

# Simulation variables
build_directory = pathlib.Path(Dir('.').abspath)
workflow_name = build_directory.name
output_file_type = "h5"
model = "Brazil_disk_rigid_platens"
params = simulation_variables_nominal.Brazilian_disk_platens

# Collect the target nodes to build a concise alias for all targets
workflow = []

# Calculations for rigid platens
arc_length = 120.
rad_diff = params['app_rad'] - params['spec_rad']
bottom_start_point = numpy.array([
    params['app_rad']*numpy.cos(numpy.deg2rad(270. - 0.5*arc_length)),
    params['app_rad']*numpy.sin(numpy.deg2rad(270. - 0.5*arc_length)) + rad_diff,])
bottom_end_point = numpy.array([
    params['app_rad']*numpy.cos(numpy.deg2rad(270. + 0.5*arc_length)),
    params['app_rad']*numpy.sin(numpy.deg2rad(270. + 0.5*arc_length)) + rad_diff,])
top_start_point = numpy.array([
    params['app_rad']*numpy.cos(numpy.deg2rad(90. - 0.5*arc_length)),
    params['app_rad']*numpy.sin(numpy.deg2rad(90. - 0.5*arc_length)) - rad_diff,])
top_end_point = numpy.array([
    params['app_rad']*numpy.cos(numpy.deg2rad(90. + 0.5*arc_length)),
    params['app_rad']*numpy.sin(numpy.deg2rad(90. + 0.5*arc_length)) - rad_diff,])
params['bottom_start_x'] = bottom_start_point[0]
params['bottom_start_y'] = bottom_start_point[1]
params['bottom_end_x'] = bottom_end_point[0]
params['bottom_end_y'] = bottom_end_point[1]
params['top_start_x'] = top_start_point[0]
params['top_start_y'] = top_start_point[1]
params['top_end_x'] = top_end_point[0]
params['top_end_y'] = top_end_point[1]
params['neg_app_rad'] = -1*params['app_rad']
params['platen_z_bot'] = rad_diff
params['platen_z_top'] = -1*rad_diff

parameter_schema = dict(
    parameter_samples = numpy.array([
        ["full_geometry", -1, -1],
        ["quarter_symmetry", -2, -2],
        ["eighth_symmetry", -4, -2],
        ], dtype=object),
    parameter_names = numpy.array(["geometry", "force_factor", "disp_factor"]))

parameter_generator = waves.parameter_generators.CustomStudy(parameter_schema)
for set_name, parameters in parameter_generator.parameter_study_to_dict().items():
    set_name = pathlib.Path(f'{build_directory/set_name}')

    geometry = parameters['geometry']
    force_factor = parameters['force_factor']
    disp_factor = parameters['disp_factor']
    model_name = f'{model}_{geometry}'
    simulation_variables = params.copy()

    # Mesh and simulation options
    abq_mesh_name = f'{model_name}_mesh'
    abq_mesh =f'{abq_mesh_name}_specimen.inp'
    mesh_options = f" --output-file {abq_mesh_name}"
    mesh_options += f" --specimen-seed-size {params['seed_size']}"
    mesh_options += f" --platen-seed-size {params['platen_seed_size']}"
    mesh_options += f" --height {params['height']}"
    mesh_options += f" --width {params['width']}"
    mesh_options += f" --chord {params['chord']}"
    mesh_options += f" --app-rad {params['app_rad']}"
    mesh_options += f" --app-dep {params['app_dep']}"
    mesh_options += f" --spec-rad {params['spec_rad']}"
    mesh_options += f" --spec-dep {params['spec_dep']}"
    mesh_options += f" --tol {params['tol']}"
    mesh_options += f" --export-platens False"
    if 'symmetry' in geometry:
        mesh_script = 'brazilian_disk_apparatus_symmetry.py'
        simulation_variables['macro_disp'] = params['macro_disp']/2
        if 'quarter' in geometry:
            mesh_options += f" --symmetry quarter"
            input_file_template = "input_rigid_platens_quarter_symmetry.inp.in"
        elif 'eighth' in geometry:
            mesh_options += f" --symmetry eighth"
            input_file_template = "input_rigid_platens_eighth_symmetry.inp.in"
    else:
        mesh_script = 'brazilian_disk_apparatus.py'
        input_file_template = "input_rigid_platens.inp.in"

    # Build mesh
    workflow.extend(env.PythonScript(
        target=[str(set_name / abq_mesh)],
        source=[str(Tardigrade_MOOSE_source_abspath / mesh_script)],
        script_options=mesh_options
        ))
    simulation_variables['specimen_mesh_file'] = abq_mesh

    # Solver Prep
    abaqus_source_list = [
        DNS_Abaqus_abspath / "brazil_disk" / input_file_template,
    ]
    workflow.extend(env.CopySubstfile(
        abaqus_source_list,
        substitution_dictionary=env.SubstitutionSyntax(simulation_variables),
        build_subdirectory=set_name
    ))

    # Abaqus Solve
    solve_source_list = [str(set_name / source_file.name.rstrip('.in')) for source_file in abaqus_source_list]
    solve_source_list.append(str(set_name / abq_mesh))
    job_name = model_name
    abaqus_options = '-double both'
    workflow.extend(env.AbaqusSolver(
        target = [f"{set_name}/{job_name}.sta"],
        source = solve_source_list,
        job_name = job_name,
        abaqus_options = abaqus_options
    ))

    # Extract Abaqus
    extract_source_list = [f"{set_name}/{job_name}.odb"]
    workflow.extend(env.AbaqusExtract(
        target = [str(set_name / file) for file in [f"{job_name}.h5", f"{job_name}_datasets.h5"]],
        source = extract_source_list,
    ))

    # Post-processing step #1 - force vs. displacement
    plot_name = f"{job_name}_force_displacement"
    plot_script = "extract_history.py"
    post_processing_source = [f"{set_name}/{job_name}_datasets.h5"]
    script_options = "--input-file " + " ".join(str(path) for path in post_processing_source)
    script_options += " --output-file ${TARGET.file} --x-units 'mm' --y-units 'N'"
    script_options += " --x-path 'BOTTOM_PLATEN-1/HistoryOutputs/RP/U2'"
    script_options += " --y-path 'BOTTOM_PLATEN-1/HistoryOutputs/RP/RF2'"
    script_options += " --x-label 'Displacement' --y-label 'Force'"
    script_options += f" --csv_file {plot_name}.csv"
    workflow.extend(env.PythonScript(
        target = [str(set_name / file) for file in [f"{plot_name}.png", f"{plot_name}.csv"]],
        source = [f"{DNS_Abaqus_abspath / plot_script}"] + post_processing_source,
        script_options = script_options
    ))

    # Post-processing step #2 - normalized force and displacements
    plot_script = "Brazil_disk_normalized_force_vs_displacements.py"
    csv_input = f"{set_name}/{plot_name}.csv"
    plot_name = f"{job_name}_force_displacement_normalized"
    script_options = f"--input-file {csv_input}"
    script_options += f" --radius {simulation_variables['spec_rad']}"
    script_options += f" --thickness {simulation_variables['spec_dep']}"
    script_options += f" --force-factor {force_factor}"
    script_options += f" --disp-factor {disp_factor}"
    script_options += f" --plot-file {plot_name}.png"
    script_options += f" --csv-file {plot_name}.csv"
    workflow.extend(env.PythonScript(
        target = [str(set_name / file) for file in [f"{plot_name}.png", f"{plot_name}.csv"]],
        source = [f"{Tardigrade_MOOSE_source_abspath / plot_script}", csv_input],
        script_options = script_options
    ))

# TODO: summarize results across each case

# Collector alias based on parent directory name
env.Alias(workflow_name, workflow)
