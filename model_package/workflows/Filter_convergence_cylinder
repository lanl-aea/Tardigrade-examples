#! /usr/bin/env python

""" Workflow for running a mesh convergence study of the micromorphic filter for an elastic cylinder under uni-axial stress in compression
Requires the following ``Sconscript(..., exports=[])``
* ``env`` - The SCons construction environment with the following required keys
TODO: complete this
"""

import pathlib

import waves
import numpy
import SCons.Defaults

from model_package.Tardigrade_MOOSE import simulation_variables_nominal


# Inherit the parent construction environment
Import('env')

# set project-wide paths with os-agnostic path separators
filter_source_abspath = pathlib.Path(env["filter_source_abspath"])
Tardigrade_MOOSE_source_abspath = pathlib.Path(env["Tardigrade_MOOSE_source_abspath"])
mesh_templates_abspath = pathlib.Path(env["mesh_templates_abspath"])

# Simulation variables
build_directory = pathlib.Path(Dir('.').abspath)
workflow_name = build_directory.name
output_file_type = "h5"
model = "filter_convergence_constant_stress"
params = simulation_variables_nominal.elastic_cylinder

# Collect the target nodes to build a concise alias for all targets
workflow = []

parameter_schema = dict(
    parameter_samples = numpy.array([
        [192, 1.0, 1000, '1k'],
        [960, 0.5, 10000, '10k'],
        [2520, 0.375, 50000, '50k'],
        [7680, 0.25, 100000, '100k'],
        ], dtype=object),
    parameter_names = numpy.array(["elements", "seed_size", "number_micro_points", "name"]))

parameter_generator = waves.parameter_generators.CustomStudy(parameter_schema)
for set_name, parameters in parameter_generator.parameter_study_to_dict().items():
    set_name = pathlib.Path(set_name)

    elements = parameters['elements']
    seed_size = parameters['seed_size']
    number_micro_points = parameters['number_micro_points']
    pts_name = parameters['name']
    model_name = f'{model}_{pts_name}'

    radius = params['diam'] / 2
    height = params['height']
    Emod = params['material_E']
    nu = params['material_nu']
    disp_z = -1*params['macro_disp']
    disp_lat = -1*nu*disp_z
    final_stress = (disp_z / height) * Emod

    # make bounds csv
    bounding_csv = f"{model}_forced_bounds.csv"
    bounding_script = "force_bounds.py"
    script_options = f"--output-file {bounding_csv}"
    script_options += f" --xmin {-1*radius} --xmax {radius}"
    script_options += f" --ymin {-1*radius} --ymax {radius}"
    script_options += f" --zmin 0 --zmax {height}"
    workflow.extend(env.PythonScript(
        target=str(set_name / bounding_csv),
        source=[str(filter_source_abspath / bounding_script)],
        script_options=script_options))

    # create filter mesh
    macro_file = f'{model_name}_MACRO'
    macro_script = "cylinder_from_bounds.py"
    mesh_targets = [f"{set_name}/{macro_file}_temp.e"]
    script_options = f"--output-file {macro_file}_temp"
    script_options += f" --bounds-file {bounding_csv}"
    script_options += f" --seed-size {seed_size}"
    if params['cut']:
        script_options += f" --cut cut"
    workflow.extend(env.PythonScript(
        target=[mesh_targets],
        source=[str(Tardigrade_MOOSE_source_abspath / macro_script), bounding_csv],
        script_options=script_options
        ))

    # convert mesh to format needed by filter
    convert_script = "xdmf_tomfoolery.py"
    new_mesh_targets = [f"{set_name}/{macro_file}.{ext}" for ext in ['xdmf', 'h5']]
    script_options = f"--output-file {macro_file}"
    script_options += f" --input-file {macro_file}_temp.e"
    workflow.extend(env.PythonScript(
        target=[new_mesh_targets],
        source=[str(filter_source_abspath / convert_script)] + mesh_targets,
        script_options=script_options
        ))

    # create microfield file
    microfield_script = 'build_microfield_study.py'
    microfield_file = f'{model_name}_MICRODATA'
    microfield_targets = [f'{set_name}/{microfield_file}.{ext}' for ext in ['xdmf', 'h5']]
    n_steps = 2
    script_options = f'--output-file {microfield_file}'
    script_options += f' --npts {number_micro_points}'
    script_options += f' --n-steps {n_steps}'
    script_options += f' --geometry cylinder'
    script_options += f' --radius {radius}'
    script_options += f' --height {height}'
    script_options += f' --disp-z {disp_z}'
    script_options += f' --disp-lat {disp_lat}'
    script_options += f' --final-stress {final_stress}'
    workflow.extend(env.PythonScript(
        target=microfield_targets,
        source=[str(filter_source_abspath / microfield_script)],
        script_options=script_options
        ))
    # write config file

    # run filter

# Collector alias based on parent directory name
env.Alias(workflow_name, workflow)

if not env['cubit']:
    print(f"Program 'cubit' was not found in construction environment. Ignoring '{workflow_name}' target(s)")
    Ignore(['.', workflow_name], workflow)
